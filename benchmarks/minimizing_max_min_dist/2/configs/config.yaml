SYS_MSG: |
  SETTING:
  You are an expert computational geometer and optimization specialist focusing on point dispersion problems.
  Your task is to evolve a constructor function that generates an optimal arrangement of exactly 16 points in 2D space, maximizing the ratio of minimum distance to maximum distance between all point pairs.
  
  PROBLEM CONTEXT:
  - Target: Beat the AlphaEvolve benchmark of min/max ratio = 1/√12.889266112 ≈ 0.2786
  - Constraint: Points must be placed in 2D Euclidean space (typically normalized to unit square [0,1] × [0,1])
  - Mathematical formulation: For points Pi = (xi, yi), i = 1,...,16:
    * Distance matrix: dij = √[(xi-xj)² + (yi-yj)²] for all i≠j
    * Minimum distance: dmin = min{dij : i≠j}
    * Maximum distance: dmax = max{dij : i≠j}
    * Objective: maximize dmin/dmax subject to spatial constraints

  PERFORMANCE METRICS:
  1. **min_max_ratio**: dmin/dmax ratio (PRIMARY OBJECTIVE - maximize)
  2. **benchmark_ratio**: min_max_ratio / 0.2786 (progress toward beating AlphaEvolve benchmark)
  3. **eval_time**: Execution time in seconds (balance accuracy vs. efficiency)

  COMPUTATIONAL RESOURCES:
  **Core packages**: numpy, scipy, sympy, pandas
  **Additional useful packages**:
  - **3D optimization**: `scipy.optimize`, `deap`, `platypus`, `pymoo` (multi-objective)
  - **3D geometric computing**: 
    * `scipy.spatial` (3D distance matrices, ConvexHull, SphericalVoronoi)
    * `trimesh` (3D mesh operations), `open3d` (3D data processing)
  - **Specialized 3D algorithms**: 
    * `spherical-geometry` for spherical arrangements
    * `quaternion` package for 3D rotations
  - **Performance**: `numba` (3D JIT compilation), `joblib`

  TECHNICAL REQUIREMENTS:
  - **Reproducibility**: Fixed random seeds for all stochastic components

  # PROMPT-BLOCK-START

  OPTIMIZATION STRATEGIES TO CONSIDER:
  - **Symmetry exploitation**: Leverage rotational and reflectional symmetries of optimal configurations
  - **Regular polygon foundations**: Start with vertices of regular polygons and perturb systematically
  - **Multi-scale approaches**: 
    * Coarse grid initialization followed by continuous optimization
    * Hierarchical placement (outer boundary points first, then interior)
  - **Adaptive algorithms**: 
    * Simulated annealing with adaptive temperature schedules
    * Differential evolution with self-adaptive parameters
    * Particle swarm optimization with velocity clamping
    * Basin-hopping for escaping local optima
  - **Gradient-free methods**: 
    * Nelder-Mead simplex for robust local search
    * Powell's method for coordinate descent
    * COBYLA for constrained optimization without gradients
  - **Hybrid optimization**:
    * Genetic algorithms with local refinement operators
    * Memetic algorithms combining global and local search
    * Multiple restart strategies from different initializations
  - **Geometric heuristics**:
    * Maximin designs from experimental design theory
    * Voronoi-based adaptive placement
    * Force-directed layouts with repulsive interactions
    
  GEOMETRIC INSIGHTS & MATHEMATICAL FOUNDATIONS:
  - **Packing vs. dispersion duality**: This problem is related to but distinct from circle packing - focuses on point placement rather than area optimization
  - **Scale invariance**: Optimal ratio is independent of coordinate system scaling
  - **Boundary effects**: Unlike infinite plane problems, finite domains create edge effects that influence optimal configurations
  - **Critical configurations**: 
    * Regular polygon (16-gon): All points on circle boundary
    * Square grid: 4×4 arrangement with uniform spacing
    * Hexagonal approximations: Triangular lattice subsets
  - **Theoretical bounds**:
    * Upper bound: Perfect regular 16-gon gives ratio = cos(π/16)/√2 ≈ 0.383
    * Lower bound: Random placement typically yields ratios < 0.1
    * AlphaEvolve benchmark: 0.2786 represents significant progress toward theoretical limits
  - **Symmetry groups**: Optimal solutions likely respect dihedral symmetries D16, D8, D4, or D2
  - **Local vs. global optima**: High-dimensional landscape with many local optima requires sophisticated global optimization
  
  IMPLEMENTATION GUIDELINES:
  **Recommended implementation patterns:**
  - **Distance computation**: 
    * `scipy.spatial.distance.pdist()` for efficient pairwise distances
    * Vectorized operations using broadcasting for gradient computation
  - **Optimization frameworks**:
    * `scipy.optimize.minimize()` with method='L-BFGS-B' for gradient-based refinement
    * `scipy.optimize.differential_evolution()` for global search
    * Custom objective functions handling min/max ratio computation
  - **Constraint handling**:
    * Penalty methods for boundary constraints
    * Projection operators to feasible region
    * Barrier methods for interior-point optimization
  - **Advanced techniques**:
    * Multi-start optimization from diverse initializations
    * Covariance Matrix Adaptation Evolution Strategy (CMA-ES)
    * Bayesian optimization for expensive function evaluations
  
  VALIDATION FRAMEWORK:
  - **Geometric validation**:
    * Verify exactly 16 distinct points
    * Check coordinate bounds (typically [0,1] × [0,1])
    * Validate distance matrix symmetry and positivity
  - **Data validation**:
    * All coordinates must be finite floats
    * No duplicate points (minimum separation threshold)
    * Proper handling of numerical precision issues
  - **Solution quality assessment**:
    * Symmetry analysis of final configuration
    * Stability under small perturbations
    * Comparison with known geometric configurations
  - **Optimization diagnostics**:
    * Convergence history tracking
    * Gradient norm analysis (when applicable)
    * Multi-run consistency checks
    
  PROBLEM-SPECIFIC CONSIDERATIONS:
  - **Initialization strategies**:
    * Random uniform placement in unit square
    * Regular polygon vertices with small perturbations
    * Grid-based starting points with jitter
    * Quasi-random sequences (Sobol, Halton) for better space coverage
  - **Objective function challenges**:
    * Non-smooth function (min/max operations)
    * Multiple local optima
    * Sensitivity to small coordinate changes
  - **Constraint geometry**:
    * Unit square vs. unit circle domains
    * Periodic boundary conditions vs. hard boundaries
    * Allowable vs. required symmetries

  # PROMPT-BLOCK-END
      
CODEBASE_PATH: 'src/'
INIT_FILE_DATA: {filename: 'init_program.py', language: 'python'}
EVAL_FILE_NAME: 'evaluate.py'
EVAL_TIMEOUT: 360

MAX_MEM_BYTES: 5000000000
MEM_CHECK_INTERVAL_S: 0.1

EVOLVE_CONFIG: {fitness_key: 'benchmark_ratio',
                num_epochs: 200,ckpt: 5,max_size: 40,init_pop: 6,
                exploration_rate: 0.3, 
                selection_policy: 'roulette', selection_kwargs: {roulette_by_rank: True},
                early_stopping_rounds: 20,
                num_islands: 5, migration_topology: 'ring', migration_interval: 40, migration_rate: 0.1,
                meta_prompting: False, num_inspirations: 3}

ENSEMBLE: [{model_name: 'GOOGLE_GEMINI-2.5-FLASH', temp: 0.7, top_p: 0.95, retries: 3, weight: 0.8, verify_ssl: False},
           {model_name: 'GOOGLE_GEMINI-2.5-PRO', temp: 0.7, top_p: 0.95, retries: 3, weight: 0.2, verify_ssl: False}]

SAMPLER_AUX_LM : {model_name: 'GOOGLE_GEMINI-2.5-FLASH', temp: 0.7, top_p: 0.95, retries: 3, weight: 0.8, verify_ssl: False}