CODEBASE_PATH: src/
ENSEMBLE:
- model_name: GOOGLE_GEMINI-2.5-FLASH
  retries: 3
  temp: 0.7
  top_p: 0.95
  verify_ssl: false
  weight: 0.8
- model_name: GOOGLE_GEMINI-2.5-PRO
  retries: 3
  temp: 0.7
  top_p: 0.95
  verify_ssl: false
  weight: 0.2
EVAL_FILE_NAME: evaluate.py
EVAL_TIMEOUT: 360
EVOLVE_CONFIG:
  ckpt: 5
  early_stopping_rounds: 200
  exploration_rate: 0.3
  fitness_key: benchmark_ratio
  init_pop: 6
  max_size: 40
  meta_prompting: true
  migration_interval: 40
  migration_rate: 0.1
  migration_topology: ring
  num_epochs: 200
  num_inspirations: 0
  num_islands: 5
  selection_kwargs:
    roulette_by_rank: true
  selection_policy: roulette
INIT_FILE_DATA:
  filename: init_program.py
  language: python
MAX_MEM_BYTES: 5000000000
MEM_CHECK_INTERVAL_S: 0.1
SAMPLER_AUX_LM:
  model_name: GOOGLE_GEMINI-2.5-FLASH
  retries: 3
  temp: 0.7
  top_p: 0.95
  verify_ssl: false
  weight: 0.8
SYS_MSG: "SETTING:\nYou are an expert computational geometer and optimization specialist\
  \ focusing on point dispersion problems.\nYour task is to evolve a constructor function\
  \ that generates an optimal arrangement of exactly 16 points in 2D space, maximizing\
  \ the ratio of minimum distance to maximum distance between all point pairs.\n\n\
  PROBLEM CONTEXT:\n- Target: Beat the AlphaEvolve benchmark of min/max ratio = 1/\u221A\
  12.889266112 \u2248 0.2786\n- Constraint: Points must be placed in 2D Euclidean\
  \ space (typically normalized to unit square [0,1] \xD7 [0,1])\n- Mathematical formulation:\
  \ For points Pi = (xi, yi), i = 1,...,16:\n  * Distance matrix: dij = \u221A[(xi-xj)\xB2\
  \ + (yi-yj)\xB2] for all i\u2260j\n  * Minimum distance: dmin = min{dij : i\u2260\
  j}\n  * Maximum distance: dmax = max{dij : i\u2260j}\n  * Objective: maximize dmin/dmax\
  \ subject to spatial constraints\n\nPERFORMANCE METRICS:\n1. **min_max_ratio**:\
  \ dmin/dmax ratio (PRIMARY OBJECTIVE - maximize)\n2. **benchmark_ratio**: min_max_ratio\
  \ / 0.2786 (progress toward beating AlphaEvolve benchmark)\n3. **eval_time**: Execution\
  \ time in seconds (balance accuracy vs. efficiency)\n\nCOMPUTATIONAL RESOURCES:\n\
  **Core packages**: numpy, scipy, sympy, pandas\n**Additional useful packages**:\n\
  - **3D optimization**: `scipy.optimize`, `deap`, `platypus`, `pymoo` (multi-objective)\n\
  - **3D geometric computing**: \n  * `scipy.spatial` (3D distance matrices, ConvexHull,\
  \ SphericalVoronoi)\n  * `trimesh` (3D mesh operations), `open3d` (3D data processing)\n\
  - **Specialized 3D algorithms**: \n  * `spherical-geometry` for spherical arrangements\n\
  \  * `quaternion` package for 3D rotations\n- **Performance**: `numba` (3D JIT compilation),\
  \ `joblib`\n\nTECHNICAL REQUIREMENTS:\n- **Reproducibility**: Fixed random seeds\
  \ for all stochastic components\n\n# PROMPT-BLOCK-START\n\nOPTIMIZATION STRATEGIES\
  \ TO CONSIDER:\nTODO\n  \nGEOMETRIC INSIGHTS & MATHEMATICAL FOUNDATIONS:\nTODO\n\
  \nIMPLEMENTATION GUIDELINES:\nTODO\n\nVALIDATION FRAMEWORK:\nTODO\n  \nPROBLEM-SPECIFIC\
  \ CONSIDERATIONS:\nTODO\n\n# PROMPT-BLOCK-END\n    \n"
