SYS_MSG: |
  SETTING:
  You are an expert computational geometer and optimization specialist with deep expertise in the Heilbronn triangle problem - a classical problem in discrete geometry that asks for the optimal placement of n points to maximize the minimum triangle area formed by any three points.

  PROBLEM SPECIFICATION:
  Your task is to design and implement a constructor function that generates an optimal arrangement of exactly 11 points within or on the boundary of an equilateral triangle with vertices at (0,0), (1,0), and (0.5, sqrt(3)/2).

  PERFORMANCE METRICS:
  1. **min_area_normalized**: Area of the smallest triangle among all point triplets (PRIMARY OBJECTIVE - maximize)
  2. **benchmark_ratio**: min_area_normalized / 0.036529889880030156 (BENCHMARK COMPARISON - maximize above 1.0)
  3. **eval_time**: Function execution time in seconds (EFFICIENCY - minimize, but secondary to quality)

  TECHNICAL REQUIREMENTS:
  - **Determinism**: Use fixed random seeds if employing stochastic methods for reproducibility
  - **Error handling**: Graceful handling of optimization failures or infeasible configurations

  COMPUTATIONAL RESOURCES & IMPLEMENTATION GUIDELINES:
  **Core packages**: numpy, scipy, sympy, pandas, networkx, jax, torch, numba, scikit-learn

  **Additional useful packages**:
  - **Advanced optimization**: `deap` (evolutionary computation), `platypus` (NSGA-II)
  - **Metaheuristics**: `scikit-opt` (particle swarm, genetic algorithms), `nevergrad` (gradient-free optimization), `optuna` (Bayesian optimization)
  - **Geometric computation**: `shapely` (computational geometry), `scipy.spatial` (Delaunay triangulation), `triangle` (mesh generation)
  - **Constraint programming**: `cvxpy` (convex optimization), `pyomo` (optimization modeling), `python-constraint`
  - **High-performance**: `cython` (C extensions), `numexpr` (fast numerical expressions)
  - **Quasi-random sampling**: `sobol_seq` for low-discrepancy point generation

  # PROMPT-BLOCK-START

  MATHEMATICAL CONTEXT & THEORETICAL BACKGROUND:
  TODO

  OPTIMIZATION STRATEGIES TO CONSIDER:
  TODO

  **Recommended implementation patterns**:
  TODO

  VALIDATION FRAMEWORK:
  TODO

  CONSTRAINTS AND CRITICAL REQUIREMENTS:
  TODO

  # PROMPT-BLOCK-END


CODEBASE_PATH: 'src/'
INIT_FILE_DATA: {filename: 'init_program.py', language: 'python'}
EVAL_FILE_NAME: 'evaluate.py'
EVAL_TIMEOUT: 360

MAX_MEM_BYTES: 5000000000
MEM_CHECK_INTERVAL_S: 0.1

EVOLVE_CONFIG: {fitness_key: 'benchmark_ratio',
                num_epochs: 200,ckpt: 5,max_size: 40,init_pop: 10,
                exploration_rate: 0.3, 
                selection_policy: 'roulette', selection_kwargs: {roulette_by_rank: True},
                early_stopping_rounds: 200,
                num_islands: 5, migration_topology: 'ring', migration_interval: 40, migration_rate: 0.1,
                meta_prompting: True, num_inspirations: 3,
                max_chat_depth: 4}

ENSEMBLE: [{model_name: 'GOOGLE_GEMINI-2.5-FLASH', temp: 0.7, top_p: 0.95, retries: 3, weight: 0.7, verify_ssl: False},
           {model_name: 'GOOGLE_GEMINI-2.5-PRO', temp: 0.9, top_p: 0.95, retries: 3, weight: 0.3, verify_ssl: False}]

SAMPLER_AUX_LM : {model_name: 'GOOGLE_GEMINI-2.5-FLASH', temp: 0.7, top_p: 0.95, retries: 3, weight: 0.8, verify_ssl: False}