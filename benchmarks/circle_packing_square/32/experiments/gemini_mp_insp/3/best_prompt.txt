SETTING:
You are an expert computational geometer and optimization specialist focusing on circle packing problems.
Your task is to evolve a constructor function that generates an optimal arrangement of exactly 32 non-overlapping circles within a unit square [0,1] × [0,1], maximizing the sum of their radii.

PROBLEM CONTEXT:
- Target: Beat the AlphaEvolve benchmark of sum_radii = 2.937
- Constraint: All circles must be fully contained within the unit square with no overlaps
- Mathematical formulation: For circle i at position (xi, yi) with radius ri:
  * Containment: ri ≤ xi ≤ 1-ri and ri ≤ yi ≤ 1-ri
  * Non-overlap: √[(xi-xj)² + (yi-yj)²] ≥ ri + rj for all i≠j
  * Objective: maximize Σri subject to above constraints

COMPUTATIONAL RESOURCES:
**Core packages**: numpy, scipy, sympy, pandas, networkx, jax, torch, numba, scikit-learn

**Additional useful packages**:
- **Optimization**: `deap` (evolutionary algorithms), `platypus` (multi-objective optimization)
- **Geometric computing**: `shapely` (geometric operations), `rtree` (spatial indexing), `scipy.spatial` (KDTree, Voronoi)
- **Constraint programming**: `python-constraint`, `ortools` (Google OR-Tools)
- **Physics simulation**: `pymunk` (2D physics), `pybullet` (physics engine)
- **Performance**: `cython`, `joblib` (parallelization)

PERFORMANCE METRICS:
1. **sum_radii**: Total sum of all 32 circle radii (PRIMARY OBJECTIVE - maximize)
2. **benchmark_ratio**: sum_radii / 2.937 (progress toward beating benchmark)  
3. **eval_time**: Execution time in seconds (keep reasonable, prefer accuracy over speed)

TECHNICAL REQUIREMENTS:
- **Determinism**: Use fixed random seeds if employing stochastic methods for reproducibility
- **Error handling**: Graceful handling of optimization failures or infeasible configurations
- **Memory efficiency**: Avoid excessive memory allocation for distance matrix computations
- **Scalability**: Design with potential extension to different circle counts in mind

# PROMPT-BLOCK-START

**Recommended implementation patterns:**
*   **Solution Representation**: Represent the configuration as a flat `np.ndarray` of shape `(N*3,)` where `N=32`. The array would contain `[x1, y1, r1, x2, y2, r2, ..., xN, yN, rN]`. This simplifies handling by optimization algorithms.
*   **Iterative Optimization**: The problem requires an iterative search algorithm due to its non-convex nature and high dimensionality.
*   **Library Choice**: Leverage `scipy.optimize` for general-purpose optimization (e.g., `differential_evolution`, `minimize` with appropriate methods like `SLSQP`, `COBYLA`, or `L-BFGS-B` combined with penalty functions). Alternatively, use specialized evolutionary algorithm libraries like `deap` or `platypus` if a genetic approach is preferred, as they are well-suited for non-convex, multi-modal problems.
*   **Modular Design**: Separate objective function, constraint functions, and the optimization loop for clarity and testability.

OPTIMIZATION STRATEGIES TO CONSIDER:
*   **Objective Function**: The primary objective is to maximize `Σri`. This can be transformed into a minimization problem by minimizing `-Σri`.
*   **Constraint Handling**:
    *   **Penalty Method**: For both containment and non-overlap constraints, add a large penalty to the objective function if any constraint is violated. The penalty should be proportional to the degree of violation. This allows gradient-based and evolutionary algorithms to explore the space more freely while penalizing infeasible solutions.
    *   **Direct Constraint Specification**: If using `scipy.optimize.minimize`, constraints can be passed explicitly. The non-overlap constraint `√[(xi-xj)² + (yi-yj)²] - (ri + rj) ≥ 0` and containment `xi - ri >= 0`, `1-ri - xi >= 0`, etc. can be formulated as `{'type': 'ineq', 'fun': lambda x: ...}`.
*   **Initial Configuration**:
    *   **Random Initialization**: Generate initial circle positions and radii randomly within bounds. This can help explore diverse regions of the search space, especially for global optimizers like `differential_evolution` or EAs.
    *   **Grid-based Initialization**: Place circles on a regular grid and assign small, equal radii, then allow the optimizer to expand them.
    *   **Small Radii Growth**: Start with very small radii for all circles and gradually increase them during optimization, allowing them to "push" each other into place.
*   **Algorithm Selection**:
    *   **Global Optimization (Recommended)**: `scipy.optimize.differential_evolution` is robust for finding global optima in complex landscapes.
    *   **Evolutionary Algorithms**: `deap` or `platypus` provide frameworks for genetic algorithms, which are excellent for non-differentiable and non-convex problems like this. They involve defining custom selection, crossover, and mutation operators.
    *   **Local Optimization (as a refinement)**: After a global search, `scipy.optimize.minimize` with a method like `SLSQP` can be used to refine the solution to a local optimum.
*   **Radii Management**: Allow radii to be variables in the optimization, subject to `r_i > 0`.

GEOMETRIC INSIGHTS & MATHEMATICAL FOUNDATIONS:
*   **NP-Hard Problem**: Circle packing is a notoriously difficult NP-hard problem. Optimal solutions are known for very small N, but for N=32, it's an open research problem to find the absolute global optimum. The goal is to find a *very good* local optimum that beats the benchmark.
*   **Non-Convexity**: The objective function with its non-overlap constraints is highly non-convex, meaning there are many local optima. This necessitates global optimization strategies.
*   **Symmetry Breaking**: Optimal solutions for circle packing often exhibit complex symmetries or, conversely, highly irregular arrangements. Avoid assumptions about symmetry in the search algorithm.
*   **Density vs. Radius Sum**: Maximizing the sum of radii is equivalent to maximizing the total area covered by the circles, which is a measure of packing density.
*   **"Force-Directed" Analogy**: Conceptually, circles can be thought of as particles repelling each other and being attracted to the center of the square (or pushing against the boundaries). This analogy can inspire heuristic approaches.
*   **Distance Matrix**: Efficient computation of pairwise distances between circle centers is critical for the non-overlap constraint. `scipy.spatial.distance.pdist` can be useful.

VALIDATION FRAMEWORK:
The solution `circles` (an `np.ndarray` of shape `(N, 3)`) must be validated against all constraints.
A `check_solution` function should:
1.  **Check Positive Radii**: Ensure all `r_i > 0`.
2.  **Check Containment**: For each circle `i` with `(xi, yi, ri)`:
    *   `ri <= xi <= 1 - ri`
    *   `ri <= yi <= 1 - ri`
3.  **Check Non-Overlap**: For every distinct pair of circles `i` and `j`:
    *   Calculate Euclidean distance `d_ij = √[(xi-xj)² + (yi-yj)²]`.
    *   Ensure `d_ij >= ri + rj`.
4.  **Calculate Sum of Radii**: `sum_radii = Σri`.

A utility function like the following might be useful:
```python
import numpy as np

def validate_and_score(circles: np.ndarray) -> tuple[float, bool, str]:
    """
    Validates a given circle packing configuration and calculates its sum of radii.

    Args:
        circles: np.array of shape (N, 3), where each row is (x, y, r).

    Returns:
        tuple[float, bool, str]: (sum_radii, is_valid, error_message)
    """
    if circles.shape[1] != 3:
        return 0.0, False, "Circles array must have shape (N, 3)."
    
    N = circles.shape[0]
    if N == 0:
        return 0.0, True, ""

    x, y, r = circles[:, 0], circles[:, 1], circles[:, 2]

    # 1. Check positive radii
    if np.any(r <= 0):
        return 0.0, False, "All radii must be positive."

    # 2. Check containment
    if np.any(x - r < 0) or np.any(x + r > 1) or \
       np.any(y - r < 0) or np.any(y + r > 1):
        return np.sum(r), False, "One or more circles are not contained within the unit square."

    # 3. Check non-overlap
    for i in range(N):
        for j in range(i + 1, N):
            dist_sq = (x[i] - x[j])**2 + (y[i] - y[j])**2
            min_dist_sq = (r[i] + r[j])**2
            if dist_sq < min_dist_sq - 1e-9: # Add a small tolerance
                return np.sum(r), False, f"Circles {i} and {j} overlap."

    total_radii = np.sum(r)
    return total_radii, True, ""

```

# PROMPT-BLOCK-END
    
