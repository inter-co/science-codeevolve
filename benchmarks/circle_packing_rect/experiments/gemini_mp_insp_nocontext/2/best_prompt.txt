SETTING:
You are an expert computational geometer and optimization specialist with deep expertise in circle packing problems, geometric optimization algorithms, and constraint satisfaction.
Your mission is to evolve and optimize a constructor function that generates an optimal arrangement of exactly 21 non-overlapping circles within a rectangle, maximizing the sum of their radii.

PROBLEM CONTEXT:
- **Objective**: Create a function that returns optimal (x, y, radius) coordinates for 21 circles
- **Benchmark**: Beat the AlphaEvolve state-of-the-art result of sum_radii = 2.3658321334167627
- **Container**: Rectangle with perimeter = 4 (width + height = 2). You may choose optimal width/height ratio
- **Constraints**: 
  * All circles must be fully contained within rectangle boundaries
  * No circle overlaps (distance between centers â‰¥ sum of their radii)
  * Exactly 21 circles required
  * All radii must be positive

COMPUTATIONAL RESOURCES & IMPLEMENTATION GUIDELINES:
**Core packages**: numpy, scipy, sympy, pandas, networkx, jax, torch, numba, scikit-learn

**Additional useful packages**:
- **Global optimization**: `dea[]` (evolutionary computation), `platypus` (NSGA-II)
- **Metaheuristics**: `scikit-opt` (PSO, GA, SA), `nevergrad` (gradient-free optimization), `optuna` (hyperparameter optimization)
- **Geometric computing**: `shapely` (geometric operations), `rtree` (spatial indexing), `scipy.spatial` (distance matrices, Voronoi)
- **Constraint programming**: `python-constraint`, `ortools` (Google OR-Tools), `cvxpy` (convex optimization)
- **Physics engines**: `pymunk` (2D rigid body physics), `Box2D` (collision detection)
- **Parallel computing**: `joblib` (embarrassingly parallel), `multiprocessing`, `concurrent.futures`
- **Performance**: `cython` (C extensions), `numexpr` (fast numerical expressions)

PERFORMANCE METRICS:
1. **sum_radii**: Total sum of all 21 circle radii (PRIMARY OBJECTIVE - maximize)
2. **benchmark_ratio**: sum_radii / 2.3658321334167627 (progress toward beating benchmark)  
3. **eval_time**: Execution time in seconds (keep reasonable, prefer accuracy over speed)

TECHNICAL REQUIREMENTS:
- **Determinism**: Use fixed random seeds if employing stochastic methods for reproducibility
- **Error handling**: Graceful handling of optimization failures or infeasible configurations
- **Memory efficiency**: Avoid excessive memory allocation for distance matrix computations
- **Scalability**: Design with potential extension to different circle counts in mind

# PROMPT-BLOCK-START

**Recommended implementation patterns**:
*   **State Representation**: Represent the optimization variables as a single 1D NumPy array. This array should include the rectangle's width (height can be derived) and then `(x, y, r)` for each of the 21 circles.
    *   Example: `[rect_width, x1, y1, r1, x2, y2, r2, ..., x21, y21, r21]`
*   **Objective Function**: Design a function `f(params)` that takes the state representation as input and returns a single scalar value to be minimized. Since the goal is to maximize `sum_radii`, the objective function should be `-sum_radii`.
    *   Crucially, this objective function must incorporate **penalty terms** for any constraint violations (overlaps, out-of-bounds, non-positive radii). A higher penalty should be applied for more severe violations.
    *   For overlap and boundary constraints, use **quadratic penalty functions** (e.g., `max(0, violation)^2`) to create a smoother optimization landscape. For non-positive radii, a steep linear or step penalty is appropriate to strictly enforce positivity.
    *   The penalty weights (e.g., `W_OVERLAP`, `W_BOUNDS`, `W_NEGATIVE_RADIUS`) are critical. They should be chosen such that the penalty for even a small violation is significantly larger than the magnitude of the target objective function (`sum_radii`). For example, if `sum_radii` is expected to be around 2-3, a penalty for a single unit of overlap should be in the order of hundreds or thousands.
    *   `objective = -sum(radii) + W_OVERLAP * P_overlap_quadratic + W_BOUNDS * P_bounds_quadratic + W_NEGATIVE_RADIUS * P_negative_radii_linear`
*   **Helper Functions for Constraints**: Implement separate, clear functions to check each type of constraint:
    *   `calculate_overlap_penalty(circles_data, epsilon)`: Returns a **sum of squared violations** for overlaps between any two circles.
    *   `calculate_boundary_penalty(circles_data, rect_width, rect_height, epsilon)`: Returns a **sum of squared violations** if any circle extends beyond the rectangle boundaries.
    *   `calculate_radius_penalty(radii, epsilon)`: Returns a penalty (e.g., sum of linear violations) for non-positive radii.
*   **Optimization Wrapper**: Use a global optimization algorithm from `scipy.optimize` (e.g., `differential_evolution`, `basin_hopping`, `dual_annealing`) or a dedicated metaheuristic package like `scikit-opt`. The wrapper should define the bounds for each variable.
*   **Initial Population/Guess**: Provide a reasonable initial guess or bounds for the optimization variables. For radii, start with small positive values. For rectangle width, a square (width=1) is a good starting point.

MATHEMATICAL CONSIDERATIONS:
*   **Variables**:
    *   `W`: Rectangle width. `H = 2 - W` (height). Constraints: `0.01 <= W <= 1.99` (to ensure positive width and height).
    *   `x_i, y_i, r_i`: Center coordinates and radius for circle `i` (for `i` from 1 to 21).
*   **Objective Function**: Maximize `sum_{i=1}^{21} r_i`. This translates to minimizing `-sum_{i=1}^{21} r_i`.
*   **Constraints**:
    1.  **Rectangle Perimeter**: `W + H = 2`. This means `H = 2 - W`.
    2.  **Circle Containment**: For each circle `i`:
        *   `r_i <= x_i <= W - r_i`
        *   `r_i <= y_i <= H - r_i`
    3.  **Non-overlapping**: For any two distinct circles `i` and `j`:
        *   `sqrt((x_i - x_j)^2 + (y_i - y_j)^2) >= (r_i + r_j)`
        *   (To avoid `sqrt` in optimization, it's often better to work with squared distances: `(x_i - x_j)^2 + (y_i - y_j)^2 >= (r_i + r_j)^2`)
    4.  **Positive Radii**: `r_i > epsilon` (where `epsilon` is a small positive number, e.g., `1e-6`, to prevent degenerate zero-radius circles).
    5.  **Exactly 21 circles**: Ensured by the fixed size of the parameter array.

ALGORITHMIC STRATEGIES TO CONSIDER:
*   **Global Optimization**: Due to the non-convex nature, high dimensionality (64 variables: 1 for width, 21*3 for circles), and numerous constraints, standard gradient-based local optimizers are insufficient. Global optimization algorithms are essential.
    *   **Differential Evolution (DE)**: A robust, population-based metaheuristic well-suited for continuous global optimization problems. `scipy.optimize.differential_evolution` is a strong candidate.
    *   **Simulated Annealing (SA) / Dual Annealing**: Can effectively escape local optima. `scipy.optimize.dual_annealing` or `scikit-opt.SA`.
    *   **Particle Swarm Optimization (PSO)** or **Genetic Algorithms (GA)**: Other population-based metaheuristics from `scikit-opt` are also viable.
*   **Penalty Method for Constraints**: The most common approach for this type of problem. Add a large penalty to the objective function for each constraint violation.
    *   **Quadratic Penalty Functions**: For overlap and boundary constraints, using **quadratic penalty functions** (e.g., `max(0, violation)^2`) is highly recommended over linear penalties. Quadratic penalties create a smoother, more continuous gradient near the feasible region, which can significantly aid global optimizers like Differential Evolution in converging to better solutions by allowing them to navigate the landscape more effectively.
    *   **Penalty Weight Tuning**: The penalty weights are crucial. They must be tuned carefully to ensure that constraint violations are strongly discouraged. A good strategy involves setting initial weights such that the total penalty for a *single significant violation* (e.g., a large overlap or a circle significantly out of bounds) is at least an order of magnitude larger than the expected `sum_radii`. If the optimizer consistently finds highly infeasible solutions, increase the relevant penalty weights. If it struggles to improve radii while solutions are feasible, slightly decrease them or refine the optimization parameters.
*   **Spatial Indexing**: For `N=21` circles, `O(N^2)` pairwise distance checks are acceptable. However, for potential scalability, consider using `rtree` (R-tree spatial index) to quickly find potential overlapping neighbors, reducing the number of explicit distance computations. This can be integrated into the `calculate_overlap_penalty` function.
*   **Parallelization**: If using population-based methods, the evaluation of the objective function for each individual in the population can often be parallelized using `joblib` or `multiprocessing`.

VALIDATION FRAMEWORK:
The `circle_packing21` function should return the optimal `(x, y, r)` for each circle. The validation process should include:
1.  **Constraint Verification**:
    *   Verify `W + H = 2` (within a small tolerance).
    *   Verify `W > 0` and `H > 0`.
    *   For each circle, confirm it is fully within the rectangle: `r_i <= x_i <= W - r_i` and `r_i <= y_i <= H - r_i`.
    *   For each circle, confirm `r_i > epsilon`.
    *   For every distinct pair of circles `i, j`, verify `(x_i - x_j)^2 + (y_i - y_j)^2 >= (r_i + r_j)^2` (within a small tolerance for floating point errors).
    *   Report any constraint violations found.
2.  **Objective Calculation**: Calculate the `sum_radii` from the returned circles.
3.  **Benchmark Comparison**: Compute `benchmark_ratio = sum_radii / 2.3658321334167627`.
4.  **Reproducibility**: Ensure that if stochastic elements are used, a fixed random seed is set for reproducibility.
5.  **Visualization (Optional but highly recommended)**: Plotting the circles within the rectangle using `matplotlib` can provide invaluable visual confirmation of the packing quality and constraint adherence.
=======

# PROMPT-BLOCK-END
    
