SETTING:
You are an expert computational geometer and optimization specialist with deep expertise in circle packing problems, geometric optimization algorithms, and constraint satisfaction.
Your mission is to evolve and optimize a constructor function that generates an optimal arrangement of exactly 21 non-overlapping circles within a rectangle, maximizing the sum of their radii.

PROBLEM CONTEXT:
- **Objective**: Create a function that returns optimal (x, y, radius) coordinates for 21 circles
- **Benchmark**: Beat the AlphaEvolve state-of-the-art result of sum_radii = 2.3658321334167627
- **Container**: Rectangle with perimeter = 4 (width + height = 2). You may choose optimal width/height ratio
- **Constraints**: 
  * All circles must be fully contained within rectangle boundaries
  * No circle overlaps (distance between centers ≥ sum of their radii)
  * Exactly 21 circles required
  * All radii must be positive

COMPUTATIONAL RESOURCES & IMPLEMENTATION GUIDELINES:
**Core packages**: numpy, scipy, sympy, pandas, networkx, jax, torch, numba, scikit-learn

**Additional useful packages**:
- **Global optimization**: `dea[]` (evolutionary computation), `platypus` (NSGA-II)
- **Metaheuristics**: `scikit-opt` (PSO, GA, SA), `nevergrad` (gradient-free optimization), `optuna` (hyperparameter optimization)
- **Geometric computing**: `shapely` (geometric operations), `rtree` (spatial indexing), `scipy.spatial` (distance matrices, Voronoi)
- **Constraint programming**: `python-constraint`, `ortools` (Google OR-Tools), `cvxpy` (convex optimization)
- **Physics engines**: `pymunk` (2D rigid body physics), `Box2D` (collision detection)
- **Parallel computing**: `joblib` (embarrassingly parallel), `multiprocessing`, `concurrent.futures`
- **Performance**: `cython` (C extensions), `numexpr` (fast numerical expressions)

PERFORMANCE METRICS:
1. **sum_radii**: Total sum of all 21 circle radii (PRIMARY OBJECTIVE - maximize)
2. **benchmark_ratio**: sum_radii / 2.3658321334167627 (progress toward beating benchmark)  
3. **eval_time**: Execution time in seconds (keep reasonable, prefer accuracy over speed)

TECHNICAL REQUIREMENTS:
- **Determinism**: Use fixed random seeds if employing stochastic methods for reproducibility
- **Error handling**: Graceful handling of optimization failures or infeasible configurations
- **Memory efficiency**: Avoid excessive memory allocation for distance matrix computations
- **Scalability**: Design with potential extension to different circle counts in mind

# PROMPT-BLOCK-START
**IMMEDIATE IMPLEMENTATION FOCUS**:
To generate a working solution, prioritize the following approach:
  - **Optimization Framework**: Use `scipy.optimize.minimize` as the primary optimization engine. It is robust for continuous optimization problems.
  - **Container Simplification**: For the initial implementation, fix the rectangle to be a square of `width=1.0` and `height=1.0`. This satisfies the perimeter constraint (width + height = 2) and simplifies the problem by deferring aspect ratio optimization.
  - **Objective Function**: Define an objective function to be *minimized*. Since the goal is to *maximize* `sum_radii`, the objective should be `-sum_radii`.
  - **Constraint Handling (Penalty Method)**: Implement all geometric constraints (non-overlap, containment, positive radii) using a penalty function approach. Add a large penalty to the objective function for any violation.
    - **Non-overlap penalty**: For each pair of circles (i, j), if `distance((xi,yi), (xj,yj)) < ri + rj`, add `K * (ri + rj - distance)^2` to the penalty, where `K` is a large constant (e.g., 1e6).
    - **Containment penalty**: For each circle (i), if `xi < ri` or `xi > width - ri` or `yi < ri` or `yi > height - ri`, add `K * (violation_amount)^2` to the penalty.
    - **Positive radii penalty**: Ensure `ri > 0`. If `ri <= 0`, add `K * (epsilon - ri)^2` to the penalty, where `epsilon` is a small positive number (e.g., 1e-6).
  - **Initial Guess**: Provide a random but reasonable initial configuration of circles. For example, place circle centers randomly within the rectangle (e.g., `x, y` in `[0.1, 0.9]`) and assign small, uniform radii (e.g., `r` in `[0.01, 0.05]`). Ensure the initial radii are positive.
  - **Solution Representation**: The optimization variable `x_opt` should be a 1D array representing `[x1, y1, r1, x2, y2, r2, ..., x21, y21, r21]`.
  - **Gradient-free local search**: Start with a simple gradient-free method like `Nelder-Mead` or `COBYLA` for `scipy.optimize.minimize`. If necessary, experiment with `SLSQP` or `trust-constr` which can handle explicit bounds.
  - **Reproducibility**: Use `np.random.seed()` for fixed initial conditions to ensure determinism.

  MATHEMATICAL CONSIDERATIONS:
  - **Aspect ratio optimization**: Golden ratio (~1.618) often emerges as optimal for packing problems, but verify empirically
  - **Circle size distribution**: Consider both uniform radii and variable radii strategies - sometimes heterogeneous sizes pack more efficiently
  - **Geometric bounds**: Maximum possible radius for any circle is min(width, height)/2; total area constraint: π∑r² ≤ width×height
  - **Distance constraints**: For circles i,j: √((xi-xj)² + (yi-yj)²) ≥ ri + rj (non-overlap)
  - **Boundary constraints**: ri ≤ xi ≤ width-ri and ri ≤ yi ≤ height-ri (containment)
  - **Symmetry exploitation**: Look for symmetric arrangements (reflection, rotation) that might be optimal
  - **Packing density**: Theoretical maximum density for infinite plane is π/(2√3) ≈ 0.9069; rectangle constraints reduce this significantly
  - **Contact graph theory**: Model circle tangencies as graph structures to identify promising geometric configurations
  
  VALIDATION FRAMEWORK:
  - **Constraint verification**: Automated checking of all geometric constraints (containment, non-overlap)
  - **Floating-point precision**: Use tolerance ε ≈ 1e-10 for numerical comparisons to handle rounding errors
  - **Visual validation**: Generate matplotlib plots showing circle arrangements for manual inspection
  - **Statistical analysis**: Run multiple seeds (≥10) and report mean, std, min, max of sum_radii across runs
  - **Benchmark comparison**: Calculate improvement percentage over AlphaEvolve baseline
  - **Regression testing**: Ensure new approaches don't degrade performance on simpler test cases
  - **Performance profiling**: Use cProfile to identify computational bottlenecks and optimize critical paths
  - **Edge case testing**: Verify behavior with extreme aspect ratios, very small/large rectangles
  - **Incremental validation**: Test with fewer circles (5, 10, 15) to build confidence in algorithmic approach
  - **Cross-validation**: Compare results across different optimization algorithms to identify consistent solutions
  # PROMPT-BLOCK-END
    
